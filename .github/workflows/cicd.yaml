# .github/workflows/cicd.yaml
# GitHub-hosted CI/CD that builds a Docker image, pushes to ECR, and redeploys on EC2 via SSH.
# Uses GitHub OIDC (no long-lived AWS keys). Replace the placeholders and add the required secrets.

name: Deploy Application Docker Image to EC2 instance

on:
  push:
    branches: [ main ]
  workflow_dispatch: {}

# Prevent parallel deploys for the same ref
concurrency:
  group: deploy-${{ github.ref }}
  cancel-in-progress: true

env:
  AWS_REGION: ap-south-1                # <-- change if needed
  ECR_REPOSITORY: myapp                 # <-- your ECR repo name (must exist)
  CONTAINER_NAME: myapp                 # <-- the container name on EC2
  CONTAINER_PORT: "80"                  # <-- container's exposed port
  HOST_PORT: "80"                       # <-- host port to publish on EC2 (e.g., 80 or 3000)

jobs:
  continuous-integration:
    runs-on: ubuntu-latest
    timeout-minutes: 30
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # Add your build/tests here if you have them
      # - uses: actions/setup-node@v4
      #   with: { node-version: 20 }
      # - run: npm ci && npm test

  continuous-deployment:
    needs: continuous-integration
    runs-on: ubuntu-latest
    timeout-minutes: 45
    permissions:
      id-token: write     # required for OIDC
      contents: read
    env:
      EC2_USER: ${{ secrets.EC2_USER }}            # e.g., "ec2-user" (Amazon Linux) or "ubuntu"
      EC2_HOST: ${{ secrets.EC2_HOST }}            # e.g., ec2-xx-xx-xx-xx.compute-1.amazonaws.com
      SSH_KEY:  ${{ secrets.EC2_SSH_PRIVATE_KEY }} # private key matching the EC2 instance's authorized_keys
      AWS_ROLE: ${{ secrets.AWS_OIDC_ROLE_ARN }}   # role with ECR + (optional) SSM/EC2 permissions
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials via OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ env.AWS_ROLE }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build, tag, and push image to ECR
        id: build-push
        run: |
          set -euo pipefail
          ECR_REGISTRY="${{ steps.ecr.outputs.registry }}"
          IMAGE_TAG="${{ github.sha }}"
          IMAGE_URI="$ECR_REGISTRY/${{ env.ECR_REPOSITORY }}:$IMAGE_TAG"

          echo "ECR_REGISTRY=$ECR_REGISTRY" >> $GITHUB_ENV
          echo "IMAGE_URI=$IMAGE_URI"       >> $GITHUB_ENV

          docker build -t "$IMAGE_URI" .
          docker push "$IMAGE_URI"

          # (Optional) also push :latest
          docker tag "$IMAGE_URI" "$ECR_REGISTRY/${{ env.ECR_REPOSITORY }}:latest"
          docker push "$ECR_REGISTRY/${{ env.ECR_REPOSITORY }}:latest"

      - name: Prepare SSH key
        run: |
          set -euo pipefail
          install -m 700 -d ~/.ssh
          echo "$SSH_KEY" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          # Preload host key to avoid prompt
          ssh-keyscan -H "$EC2_HOST" >> ~/.ssh/known_hosts

      - name: Deploy to EC2 via SSH
        env:
          ECR_REGISTRY: ${{ steps.ecr.outputs.registry }}
          IMAGE_URI: ${{ env.IMAGE_URI }}
        run: |
          set -euo pipefail

          # Remote script:
          # - Login to ECR (instance must have AWS CLI installed).
          # - Pull new image.
          # - Stop & remove existing container if present.
          # - Run new container detached on the specified port(s).
          # NOTE: Best practice is to grant the EC2 instance an IAM role with ECR pull permissions.
          ssh -o StrictHostKeyChecking=yes "${EC2_USER}@${EC2_HOST}" bash -s <<'REMOTE_EOF'
            set -euo pipefail
            AWS_REGION="${AWS_REGION}"
            ECR_REGISTRY="${ECR_REGISTRY}"
            IMAGE_URI="${IMAGE_URI}"
            CONTAINER_NAME="${CONTAINER_NAME}"
            CONTAINER_PORT="${CONTAINER_PORT}"
            HOST_PORT="${HOST_PORT}"

            # Login to ECR (using the instance profile's permissions)
            aws ecr get-login-password --region "$AWS_REGION" \
              | docker login --username AWS --password-stdin "$ECR_REGISTRY"

            # Pull the new image
            docker pull "$IMAGE_URI"

            # Stop and remove old container if exists
            if docker ps -a --format '{{.Names}}' | grep -q "^${CONTAINER_NAME}\$"; then
              docker rm -f "${CONTAINER_NAME}" || true
            fi

            # (Optional) prune dangling images to free space
            docker image prune -f || true

            # Run the new container
            docker run -d --name "${CONTAINER_NAME}" \
              -p "${HOST_PORT}:${CONTAINER_PORT}" \
              --restart=always \
              "$IMAGE_URI"

            # Health check / show status
            docker ps --filter "name=${CONTAINER_NAME}"
          REMOTE_EOF
